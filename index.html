<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Deceleration Curve Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0px;
            background: #000;
            color: #e0e0e0;
        }
        .container {
            background: #000;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .file-input {
            margin-bottom: 20px;
            padding: 10px;
            border: 2px dashed #555;
            border-radius: 5px;
            text-align: center;
            background: #333;
        }
        .file-input input {
            margin: 10px;
            background: #444;
            color: #e0e0e0;
            border: 1px solid #666;
            padding: 5px;
            border-radius: 3px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #555;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00d4ff;
        }
        .stat-label {
            color: #bbb;
            font-size: 0.9em;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }
        .weight-selector {
            margin: 15px 0;
        }
        .weight-selector select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #666;
            background: #444;
            color: #e0e0e0;
        }
        .weight-selector label {
            color: #e0e0e0;
        }
        .error {
            color: #ff6b6b;
            padding: 10px;
            background: #3d1a1a;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #cc4444;
        }
        .success {
            color: #51cf66;
            padding: 10px;
            background: #1a3d1a;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #44cc44;
        }
        .export-section {
            margin: 15px 0;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #555;
        }
        .export-btn {
            background: #00d4ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        .export-btn:hover {
            background: #00b8e6;
        }
        .export-btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
        }
        h1 {
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ›’ Cart Deceleration Curve Analyzer</h1>

```
    <div class="file-input">
        <p>Select a file containing cart log data:</p>
        <input type="file" id="fileInput" accept=".txt,.log" />
        <p><small>Expected format: timestamp[Scripting][inform]-Cart -ID (type) â†’ x=X, y=Y, z=Z, weight=W</small></p>
    </div>

    <div id="message"></div>

    <div class="weight-selector" id="weightSelector" style="display: none;">
        <label for="weightSelect">Select Weight to Display:</label>
        <select id="weightSelect">
            <option value="all">All Weights</option>
        </select>
    </div>

    <div class="export-section" id="exportSection" style="display: none;">
        <h3>Export Analysis</h3>
        <p>Download detailed deceleration analysis for all weights:</p>
        <button class="export-btn" id="exportBtn" onclick="exportDecelerationData()">
            ðŸ“Š Export Deceleration Analysis (TXT)
        </button>
    </div>

    <div class="stats" id="stats" style="display: none;">
        <div class="stat-card">
            <div class="stat-value" id="totalEntries">0</div>
            <div class="stat-label">Total Entries</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="uniqueWeights">0</div>
            <div class="stat-label">Unique Weights</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="timeRange">0s</div>
            <div class="stat-label">Time Range</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="avgDeceleration">0</div>
            <div class="stat-label">Avg Deceleration</div>
        </div>
    </div>

    <div class="chart-container">
        <canvas id="decelerationChart"></canvas>
    </div>
</div>

<script>
    let cartData = [];
    let chart = null;
    let allParsedData = [];

    // Initialize empty chart
    const ctx = document.getElementById('decelerationChart').getContext('2d');
    chart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: []
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Cart Position Over Time (X-Coordinate)',
                    color: '#e0e0e0'
                },
                legend: {
                    display: true,
                    labels: {
                        color: '#e0e0e0'
                    }
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    title: {
                        display: true,
                        text: 'Time (seconds)',
                        color: '#e0e0e0'
                    },
                    ticks: {
                        color: '#e0e0e0'
                    },
                    grid: {
                        color: '#444'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'X Coordinate',
                        color: '#e0e0e0'
                    },
                    ticks: {
                        color: '#e0e0e0'
                    },
                    grid: {
                        color: '#444'
                    }
                }
            }
        }
    });

    document.getElementById('fileInput').addEventListener('change', handleFileSelect);
    document.getElementById('weightSelect').addEventListener('change', updateChart);

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                parseCartData(e.target.result);
                showMessage('File loaded successfully!', 'success');
            } catch (error) {
                showMessage('Error parsing file: ' + error.message, 'error');
            }
        };
        reader.readAsText(file);
    }

    function parseCartData(fileContent) {
        const lines = fileContent.split('\n');
        const parsedData = [];
        
        // Regex to match the log format
        const logRegex = /(\d{2}:\d{2}:\d{2})\[Scripting\]\[inform\]-Cart\s+-?\d+\s+\([^)]+\)\s+â†’\s+x=([^,]+),\s+y=([^,]+),\s+z=([^,]+),\s+weight=(\d+)/;
        
        let baseTime = null;
        
        for (let line of lines) {
            line = line.trim();
            if (!line) continue;
            
            const match = line.match(logRegex);
            if (match) {
                const [, timeStr, xStr, yStr, zStr, weightStr] = match;
                
                // Parse time
                const [hours, minutes, seconds] = timeStr.split(':').map(Number);
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                
                // Set base time from first entry
                if (baseTime === null) {
                    baseTime = totalSeconds;
                }
                
                const relativeTime = totalSeconds - baseTime;
                
                parsedData.push({
                    time: relativeTime,
                    x: parseFloat(xStr),
                    y: parseFloat(yStr),
                    z: parseFloat(zStr),
                    weight: parseInt(weightStr),
                    timestamp: timeStr
                });
            }
        }
        
        if (parsedData.length === 0) {
            throw new Error('No valid cart data found in file');
        }
        
        // Sort by time
        parsedData.sort((a, b) => a.time - b.time);
        
        allParsedData = parsedData;
        setupWeightSelector();
        updateStats();
        updateChart();
    }

    function setupWeightSelector() {
        const weights = [...new Set(allParsedData.map(d => d.weight))].sort((a, b) => a - b);
        const select = document.getElementById('weightSelect');
        
        // Clear existing options except "All Weights"
        select.innerHTML = '<option value="all">All Weights</option>';
        
        weights.forEach(weight => {
            const option = document.createElement('option');
            option.value = weight;
            option.textContent = `Weight ${weight}`;
            select.appendChild(option);
        });
        
        document.getElementById('weightSelector').style.display = 'block';
    }

    function findDecelerationStart(data) {
        if (data.length < 3) return 0;
        
        // Calculate velocity between consecutive points
        const velocities = [];
        for (let i = 1; i < data.length; i++) {
            const dx = data[i].x - data[i-1].x;
            const dt = data[i].time - data[i-1].time;
            if (dt > 0) {
                velocities.push({ index: i, velocity: dx / dt });
            }
        }
        
        if (velocities.length < 2) return 0;
        
        // Find the point where velocity starts consistently decreasing
        // Look for the maximum velocity and start from there
        let maxVelocityIndex = 0;
        let maxVelocity = velocities[0].velocity;
        
        for (let i = 0; i < velocities.length; i++) {
            if (velocities[i].velocity > maxVelocity) {
                maxVelocity = velocities[i].velocity;
                maxVelocityIndex = i;
            }
        }
        
        // Start from the maximum velocity point
        return velocities[maxVelocityIndex].index;
    }

    function findStopPoint(data, startIndex) {
        if (data.length < startIndex + 3) return data.length;
        
        const threshold = 0.001; // Movement threshold - adjust as needed
        const checkWindow = 3; // Check this many consecutive points
        
        for (let i = startIndex + checkWindow; i < data.length; i++) {
            let isStationary = true;
            
            // Check if cart has been stationary for 'checkWindow' points
            for (let j = 0; j < checkWindow; j++) {
                const dx = Math.abs(data[i - j].x - data[i - j - 1].x);
                if (dx > threshold) {
                    isStationary = false;
                    break;
                }
            }
            
            if (isStationary) {
                return i - checkWindow + 1; // Return the first point where it stopped
            }
        }
        
        return data.length; // If never stops, return full length
    }

    function interpolateSpline(data, targetPoints) {
        if (data.length < 4) return data;
        
        // Simple spline interpolation using cubic interpolation
        const result = [];
        const n = data.length;
        
        for (let i = 0; i < targetPoints; i++) {
            const t = i / (targetPoints - 1);
            const index = t * (n - 1);
            const baseIndex = Math.floor(index);
            const fraction = index - baseIndex;
            
            if (baseIndex >= n - 1) {
                result.push(data[n - 1]);
                continue;
            }
            
            // Get 4 points for cubic interpolation
            const p0 = data[Math.max(0, baseIndex - 1)];
            const p1 = data[baseIndex];
            const p2 = data[Math.min(n - 1, baseIndex + 1)];
            const p3 = data[Math.min(n - 1, baseIndex + 2)];
            
            // Cubic interpolation
            const t2 = fraction * fraction;
            const t3 = t2 * fraction;
            
            const x = 0.5 * (
                (2 * p1.x) +
                (-p0.x + p2.x) * fraction +
                (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
            );
            
            const y = 0.5 * (
                (2 * p1.y) +
                (-p0.y + p2.y) * fraction +
                (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
            );
            
            result.push({ x, y });
        }
        
        return result;
    }

    function generateUniqueColors(count) {
        // High contrast colors optimized for dark backgrounds
        const baseColors = [
            '#ff6b6b', '#51cf66', '#339af0', '#ffd43b', '#ff8cc8',
            '#69db7c', '#74c0fc', '#ffa8a8', '#b197fc', '#63e6be',
            '#91a7ff', '#ffc947', '#ff9ff3', '#8ce99a', '#74dbf4',
            '#ffd966', '#da77f2', '#96f2d7', '#a78bfa', '#fed7aa',
            '#f783ac', '#bfdbfe', '#fde68a', '#c084fc', '#86efac',
            '#fbbf24', '#f472b6', '#60a5fa', '#a3e635', '#fb7185',
            '#34d399', '#fbbf24', '#e879f9', '#22d3ee', '#fb923c',
            '#4ade80', '#818cf8', '#facc15', '#f87171', '#06b6d4'
        ];
        
        const colors = [];
        
        for (let i = 0; i < count; i++) {
            if (i < baseColors.length) {
                colors.push(baseColors[i]);
            } else {
                // Generate additional colors using HSL with high saturation and lightness
                const hue = (i * 137.508) % 360; // Golden angle approximation
                const saturation = 80 + (i % 3) * 10;
                const lightness = 60 + (i % 4) * 10;
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
        }
        
        return colors;
    }

    function updateChart() {
        const selectedWeight = document.getElementById('weightSelect').value;
        
        let datasets = [];
        
        if (selectedWeight === 'all') {
            // Group by weight and create a dataset for each
            const weightGroups = {};
            allParsedData.forEach(point => {
                if (!weightGroups[point.weight]) {
                    weightGroups[point.weight] = [];
                }
                weightGroups[point.weight].push(point);
            });
            
            const weightKeys = Object.keys(weightGroups).sort((a, b) => Number(a) - Number(b));
            const colors = generateUniqueColors(weightKeys.length);
            let colorIndex = 0;
            
            weightKeys.forEach(weight => {
                const fullData = weightGroups[weight];
                const startIndex = findDecelerationStart(fullData);
                const stopIndex = findStopPoint(fullData, startIndex);
                const decelerationData = fullData.slice(startIndex, stopIndex);
                
                if (decelerationData.length > 0) {
                    // Reset time to start from 0 at deceleration start
                    const startTime = decelerationData[0].time;
                    let adjustedData = decelerationData.map(point => ({
                        x: point.time - startTime,
                        y: point.x
                    }));
                    
                    // Apply smoothing based on data density
                    const dataPoints = adjustedData.length;
                    const targetPoints = Math.min(dataPoints * 2, 500); // Adaptive interpolation
                    
                    if (dataPoints > 10 && targetPoints > dataPoints) {
                        adjustedData = interpolateSpline(adjustedData, targetPoints);
                    }
                    
                    const color = colors[colorIndex];
                    
                    datasets.push({
                        label: `Weight ${weight}`,
                        data: adjustedData,
                        borderColor: color,
                        backgroundColor: color + '20',
                        fill: false,
                        tension: 0.4, // Increased tension for smoother curves
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        borderWidth: 2,
                        cubicInterpolationMode: 'monotone' // Ensures smooth curves
                    });
                    
                    colorIndex++;
                }
            });
        } else {
            // Show only selected weight
            const fullData = allParsedData.filter(point => point.weight == selectedWeight);
            const startIndex = findDecelerationStart(fullData);
            const stopIndex = findStopPoint(fullData, startIndex);
            const decelerationData = fullData.slice(startIndex, stopIndex);
            
            if (decelerationData.length > 0) {
                // Reset time to start from 0 at deceleration start
                const startTime = decelerationData[0].time;
                let adjustedData = decelerationData.map(point => ({
                    x: point.time - startTime,
                    y: point.x
                }));
                
                // Apply smoothing based on data density
                const dataPoints = adjustedData.length;
                const targetPoints = Math.min(dataPoints * 2, 500);
                
                if (dataPoints > 10 && targetPoints > dataPoints) {
                    adjustedData = interpolateSpline(adjustedData, targetPoints);
                }
                
                datasets.push({
                    label: `Weight ${selectedWeight}`,
                    data: adjustedData,
                    borderColor: '#51cf66',
                    backgroundColor: '#51cf6620',
                    fill: false,
                    tension: 0.4, // Increased tension for smoother curves
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    borderWidth: 2,
                    cubicInterpolationMode: 'monotone' // Ensures smooth curves
                });
            }
        }
        
        chart.data.datasets = datasets;
        chart.update();
    }

    function updateStats() {
        const weights = [...new Set(allParsedData.map(d => d.weight))];
        const timeRange = allParsedData.length > 0 ? 
            Math.max(...allParsedData.map(d => d.time)) - Math.min(...allParsedData.map(d => d.time)) : 0;
        
        // Calculate average deceleration (change in velocity over time)
        let totalDeceleration = 0;
        let decelerationCount = 0;
        
        weights.forEach(weight => {
            const weightData = allParsedData.filter(d => d.weight === weight);
            if (weightData.length > 1) {
                for (let i = 1; i < weightData.length; i++) {
                    const dx = weightData[i].x - weightData[i-1].x;
                    const dt = weightData[i].time - weightData[i-1].time;
                    if (dt > 0) {
                        const velocity = dx / dt;
                        totalDeceleration += Math.abs(velocity);
                        decelerationCount++;
                    }
                }
            }
        });
        
        const avgDeceleration = decelerationCount > 0 ? (totalDeceleration / decelerationCount).toFixed(3) : 0;
        
        document.getElementById('totalEntries').textContent = allParsedData.length;
        document.getElementById('uniqueWeights').textContent = weights.length;
        document.getElementById('timeRange').textContent = timeRange.toFixed(1) + 's';
        document.getElementById('avgDeceleration').textContent = avgDeceleration;
        
        document.getElementById('stats').style.display = 'grid';
        document.getElementById('exportSection').style.display = 'block';
    }

    function calculateDecelerationMetrics(data) {
        if (data.length < 3) return null;
        
        const metrics = {
            totalDistance: 0,
            totalTime: 0,
            avgVelocity: 0,
            maxVelocity: 0,
            minVelocity: 0,
            avgDeceleration: 0,
            maxDeceleration: 0,
            decelerationPoints: [],
            velocityPoints: []
        };
        
        // Calculate velocities and accelerations
        for (let i = 1; i < data.length; i++) {
            const dx = data[i].x - data[i-1].x;
            const dt = data[i].time - data[i-1].time;
            
            if (dt > 0) {
                const velocity = dx / dt;
                metrics.velocityPoints.push({
                    time: data[i].time,
                    velocity: velocity,
                    position: data[i].x
                });
                
                if (velocity > metrics.maxVelocity) metrics.maxVelocity = velocity;
                if (velocity < metrics.minVelocity) metrics.minVelocity = velocity;
            }
        }
        
        // Calculate accelerations (deceleration = negative acceleration)
        for (let i = 1; i < metrics.velocityPoints.length; i++) {
            const dv = metrics.velocityPoints[i].velocity - metrics.velocityPoints[i-1].velocity;
            const dt = metrics.velocityPoints[i].time - metrics.velocityPoints[i-1].time;
            
            if (dt > 0) {
                const acceleration = dv / dt;
                metrics.decelerationPoints.push({
                    time: metrics.velocityPoints[i].time,
                    acceleration: acceleration,
                    deceleration: -acceleration, // Positive deceleration
                    velocity: metrics.velocityPoints[i].velocity
                });
                
                if (Math.abs(acceleration) > metrics.maxDeceleration) {
                    metrics.maxDeceleration = Math.abs(acceleration);
                }
            }
        }
        
        // Calculate averages
        if (metrics.velocityPoints.length > 0) {
            metrics.avgVelocity = metrics.velocityPoints.reduce((sum, p) => sum + Math.abs(p.velocity), 0) / metrics.velocityPoints.length;
        }
        
        if (metrics.decelerationPoints.length > 0) {
            metrics.avgDeceleration = metrics.decelerationPoints.reduce((sum, p) => sum + Math.abs(p.acceleration), 0) / metrics.decelerationPoints.length;
        }
        
        // Calculate total distance and time
        if (data.length > 0) {
            metrics.totalDistance = Math.abs(data[data.length - 1].x - data[0].x);
            metrics.totalTime = data[data.length - 1].time - data[0].time;
        }
        
        return metrics;
    }

    function exportDecelerationData() {
        if (allParsedData.length === 0) {
            showMessage('No data to export', 'error');
            return;
        }
        
        const exportData = [];
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        
        exportData.push('===========================================');
        exportData.push('CART DECELERATION ANALYSIS REPORT');
        exportData.push('===========================================');
        exportData.push(`Generated: ${new Date().toLocaleString()}`);
        exportData.push(`Total Data Points: ${allParsedData.length}`);
        exportData.push('');
        
        // Group by weight and analyze each
        const weightGroups = {};
        allParsedData.forEach(point => {
            if (!weightGroups[point.weight]) {
                weightGroups[point.weight] = [];
            }
            weightGroups[point.weight].push(point);
        });
        
        const weightKeys = Object.keys(weightGroups).sort((a, b) => Number(a) - Number(b));
        
        // Summary table
        exportData.push('SUMMARY BY WEIGHT:');
        exportData.push('-------------------------------------------');
        exportData.push('Weight | Avg Decel | Max Decel | Avg Velocity | Distance | Time');
        exportData.push('-------|-----------|-----------|--------------|----------|------');
        
        const summaryData = [];
        
        weightKeys.forEach(weight => {
            const fullData = weightGroups[weight];
            const startIndex = findDecelerationStart(fullData);
            const stopIndex = findStopPoint(fullData, startIndex);
            const decelerationData = fullData.slice(startIndex, stopIndex);
            
            if (decelerationData.length > 0) {
                // Reset time to start from 0 at deceleration start
                const startTime = decelerationData[0].time;
                const adjustedData = decelerationData.map(point => ({
                    time: point.time - startTime,
                    x: point.x,
                    y: point.y,
                    z: point.z
                }));
                
                const metrics = calculateDecelerationMetrics(adjustedData);
                
                if (metrics) {
                    summaryData.push({
                        weight: weight,
                        metrics: metrics,
                        rawData: adjustedData
                    });
                    
                    const line = `${weight.padStart(6)} | ${metrics.avgDeceleration.toFixed(3).padStart(9)} | ${metrics.maxDeceleration.toFixed(3).padStart(9)} | ${metrics.avgVelocity.toFixed(3).padStart(12)} | ${metrics.totalDistance.toFixed(2).padStart(8)} | ${metrics.totalTime.toFixed(1).padStart(4)}s`;
                    exportData.push(line);
                }
            }
        });
        
        exportData.push('');
        exportData.push('===========================================');
        exportData.push('DETAILED ANALYSIS BY WEIGHT');
        exportData.push('===========================================');
        
        // Detailed analysis for each weight
        summaryData.forEach(({ weight, metrics, rawData }) => {
            exportData.push('');
            exportData.push(`WEIGHT: ${weight}`);
            exportData.push('-------------------------------------------');
            exportData.push(`Total Distance: ${metrics.totalDistance.toFixed(3)} units`);
            exportData.push(`Total Time: ${metrics.totalTime.toFixed(3)} seconds`);
            exportData.push(`Average Velocity: ${metrics.avgVelocity.toFixed(3)} units/sec`);
            exportData.push(`Maximum Velocity: ${metrics.maxVelocity.toFixed(3)} units/sec`);
            exportData.push(`Minimum Velocity: ${metrics.minVelocity.toFixed(3)} units/sec`);
            exportData.push(`Average Deceleration: ${metrics.avgDeceleration.toFixed(3)} units/secÂ²`);
            exportData.push(`Maximum Deceleration: ${metrics.maxDeceleration.toFixed(3)} units/secÂ²`);
            exportData.push('');
            
            // Top 10 highest deceleration moments
            const topDecelerations = metrics.decelerationPoints
                .sort((a, b) => b.deceleration - a.deceleration)
                .slice(0, 10);
            
            if (topDecelerations.length > 0) {
                exportData.push('Top 10 Highest Deceleration Moments:');
                exportData.push('Time(s) | Deceleration | Velocity | Position');
                exportData.push('--------|--------------|----------|----------');
                
                topDecelerations.forEach(point => {
                    const line = `${point.time.toFixed(2).padStart(7)} | ${point.deceleration.toFixed(3).padStart(12)} | ${point.velocity.toFixed(3).padStart(8)} | ${point.velocity > 0 ? point.velocity.toFixed(2) : 'N/A'}`;
                    exportData.push(line);
                });
            }
            
            exportData.push('');
            
            // Velocity profile (every 10th point to avoid too much data)
            if (metrics.velocityPoints.length > 0) {
                exportData.push('Velocity Profile (Sample Points):');
                exportData.push('Time(s) | Velocity | Position');
                exportData.push('--------|----------|----------');
                
                const step = Math.max(1, Math.floor(metrics.velocityPoints.length / 20));
                for (let i = 0; i < metrics.velocityPoints.length; i += step) {
                    const point = metrics.velocityPoints[i];
                    const line = `${point.time.toFixed(2).padStart(7)} | ${point.velocity.toFixed(3).padStart(8)} | ${point.position.toFixed(3).padStart(8)}`;
                    exportData.push(line);
                }
            }
            
            exportData.push('');
            exportData.push('===========================================');
        });
        
        // Add comparison analysis
        if (summaryData.length > 1) {
            exportData.push('');
            exportData.push('COMPARATIVE ANALYSIS');
            exportData.push('===========================================');
            
            const avgDecelerations = summaryData.map(s => s.metrics.avgDeceleration);
            const maxDecelerations = summaryData.map(s => s.metrics.maxDeceleration);
            const avgVelocities = summaryData.map(s => s.metrics.avgVelocity);
            
            exportData.push(`Highest Average Deceleration: Weight ${summaryData[avgDecelerations.indexOf(Math.max(...avgDecelerations))].weight} (${Math.max(...avgDecelerations).toFixed(3)} units/secÂ²)`);
            exportData.push(`Lowest Average Deceleration: Weight ${summaryData[avgDecelerations.indexOf(Math.min(...avgDecelerations))].weight} (${Math.min(...avgDecelerations).toFixed(3)} units/secÂ²)`);
            exportData.push(`Highest Peak Deceleration: Weight ${summaryData[maxDecelerations.indexOf(Math.max(...maxDecelerations))].weight} (${Math.max(...maxDecelerations).toFixed(3)} units/secÂ²)`);
            exportData.push(`Fastest Average Speed: Weight ${summaryData[avgVelocities.indexOf(Math.max(...avgVelocities))].weight} (${Math.max(...avgVelocities).toFixed(3)} units/sec)`);
            exportData.push(`Slowest Average Speed: Weight ${summaryData[avgVelocities.indexOf(Math.min(...avgVelocities))].weight} (${Math.min(...avgVelocities).toFixed(3)} units/sec)`);
            
            // Weight vs Performance correlation
            exportData.push('');
            exportData.push('Weight vs Performance Correlation:');
            exportData.push('Weight | Decel Rate | Performance Index*');
            exportData.push('-------|------------|------------------');
            
            summaryData.forEach(({ weight, metrics }) => {
                const performanceIndex = (metrics.avgVelocity / metrics.avgDeceleration) * 100;
                const line = `${weight.padStart(6)} | ${metrics.avgDeceleration.toFixed(3).padStart(10)} | ${performanceIndex.toFixed(1).padStart(17)}`;
                exportData.push(line);
            });
            
            exportData.push('');
            exportData.push('*Performance Index = (Avg Velocity / Avg Deceleration) Ã— 100');
            exportData.push('Higher values indicate better performance (faster speed, lower deceleration)');
        }
        
        // Create and download file
        const blob = new Blob([exportData.join('\n')], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cart-deceleration-analysis-${timestamp}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showMessage('Deceleration analysis exported successfully!', 'success');
    }

    function showMessage(text, type) {
        const messageDiv = document.getElementById('message');
        messageDiv.textContent = text;
        messageDiv.className = type;
        messageDiv.style.display = 'block';
        
        if (type === 'success') {
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 3000);
        }
    }
</script>
```

</body>
</html>
